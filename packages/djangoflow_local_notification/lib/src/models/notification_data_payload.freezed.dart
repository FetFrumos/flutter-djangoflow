// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'notification_data_payload.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

NotificationDataPayload _$NotificationDataPayloadFromJson(
    Map<String, dynamic> json) {
  return _NotificationDataPayload.fromJson(json);
}

/// @nodoc
mixin _$NotificationDataPayload {
  String? get notificationId => throw _privateConstructorUsedError;
  String? get id => throw _privateConstructorUsedError;
  String? get title => throw _privateConstructorUsedError;
  String? get actionCategoryId => throw _privateConstructorUsedError;
  String? get body => throw _privateConstructorUsedError;
  String? get actions => throw _privateConstructorUsedError;
  String? get url => throw _privateConstructorUsedError;
  String? get dismissed => throw _privateConstructorUsedError;
  String? get multiline => throw _privateConstructorUsedError;
  String? get image => throw _privateConstructorUsedError;
  Map<String, dynamic>? get payload => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $NotificationDataPayloadCopyWith<NotificationDataPayload> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NotificationDataPayloadCopyWith<$Res> {
  factory $NotificationDataPayloadCopyWith(NotificationDataPayload value,
          $Res Function(NotificationDataPayload) then) =
      _$NotificationDataPayloadCopyWithImpl<$Res, NotificationDataPayload>;
  @useResult
  $Res call(
      {String? notificationId,
      String? id,
      String? title,
      String? actionCategoryId,
      String? body,
      String? actions,
      String? url,
      String? dismissed,
      String? multiline,
      String? image,
      Map<String, dynamic>? payload});
}

/// @nodoc
class _$NotificationDataPayloadCopyWithImpl<$Res,
        $Val extends NotificationDataPayload>
    implements $NotificationDataPayloadCopyWith<$Res> {
  _$NotificationDataPayloadCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? notificationId = freezed,
    Object? id = freezed,
    Object? title = freezed,
    Object? actionCategoryId = freezed,
    Object? body = freezed,
    Object? actions = freezed,
    Object? url = freezed,
    Object? dismissed = freezed,
    Object? multiline = freezed,
    Object? image = freezed,
    Object? payload = freezed,
  }) {
    return _then(_value.copyWith(
      notificationId: freezed == notificationId
          ? _value.notificationId
          : notificationId // ignore: cast_nullable_to_non_nullable
              as String?,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      title: freezed == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      actionCategoryId: freezed == actionCategoryId
          ? _value.actionCategoryId
          : actionCategoryId // ignore: cast_nullable_to_non_nullable
              as String?,
      body: freezed == body
          ? _value.body
          : body // ignore: cast_nullable_to_non_nullable
              as String?,
      actions: freezed == actions
          ? _value.actions
          : actions // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      dismissed: freezed == dismissed
          ? _value.dismissed
          : dismissed // ignore: cast_nullable_to_non_nullable
              as String?,
      multiline: freezed == multiline
          ? _value.multiline
          : multiline // ignore: cast_nullable_to_non_nullable
              as String?,
      image: freezed == image
          ? _value.image
          : image // ignore: cast_nullable_to_non_nullable
              as String?,
      payload: freezed == payload
          ? _value.payload
          : payload // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$NotificationDataPayloadImplCopyWith<$Res>
    implements $NotificationDataPayloadCopyWith<$Res> {
  factory _$$NotificationDataPayloadImplCopyWith(
          _$NotificationDataPayloadImpl value,
          $Res Function(_$NotificationDataPayloadImpl) then) =
      __$$NotificationDataPayloadImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? notificationId,
      String? id,
      String? title,
      String? actionCategoryId,
      String? body,
      String? actions,
      String? url,
      String? dismissed,
      String? multiline,
      String? image,
      Map<String, dynamic>? payload});
}

/// @nodoc
class __$$NotificationDataPayloadImplCopyWithImpl<$Res>
    extends _$NotificationDataPayloadCopyWithImpl<$Res,
        _$NotificationDataPayloadImpl>
    implements _$$NotificationDataPayloadImplCopyWith<$Res> {
  __$$NotificationDataPayloadImplCopyWithImpl(
      _$NotificationDataPayloadImpl _value,
      $Res Function(_$NotificationDataPayloadImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? notificationId = freezed,
    Object? id = freezed,
    Object? title = freezed,
    Object? actionCategoryId = freezed,
    Object? body = freezed,
    Object? actions = freezed,
    Object? url = freezed,
    Object? dismissed = freezed,
    Object? multiline = freezed,
    Object? image = freezed,
    Object? payload = freezed,
  }) {
    return _then(_$NotificationDataPayloadImpl(
      notificationId: freezed == notificationId
          ? _value.notificationId
          : notificationId // ignore: cast_nullable_to_non_nullable
              as String?,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      title: freezed == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      actionCategoryId: freezed == actionCategoryId
          ? _value.actionCategoryId
          : actionCategoryId // ignore: cast_nullable_to_non_nullable
              as String?,
      body: freezed == body
          ? _value.body
          : body // ignore: cast_nullable_to_non_nullable
              as String?,
      actions: freezed == actions
          ? _value.actions
          : actions // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      dismissed: freezed == dismissed
          ? _value.dismissed
          : dismissed // ignore: cast_nullable_to_non_nullable
              as String?,
      multiline: freezed == multiline
          ? _value.multiline
          : multiline // ignore: cast_nullable_to_non_nullable
              as String?,
      image: freezed == image
          ? _value.image
          : image // ignore: cast_nullable_to_non_nullable
              as String?,
      payload: freezed == payload
          ? _value._payload
          : payload // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$NotificationDataPayloadImpl implements _NotificationDataPayload {
  const _$NotificationDataPayloadImpl(
      {this.notificationId,
      this.id,
      this.title,
      this.actionCategoryId,
      this.body,
      this.actions,
      this.url,
      this.dismissed,
      this.multiline,
      this.image,
      final Map<String, dynamic>? payload})
      : _payload = payload;

  factory _$NotificationDataPayloadImpl.fromJson(Map<String, dynamic> json) =>
      _$$NotificationDataPayloadImplFromJson(json);

  @override
  final String? notificationId;
  @override
  final String? id;
  @override
  final String? title;
  @override
  final String? actionCategoryId;
  @override
  final String? body;
  @override
  final String? actions;
  @override
  final String? url;
  @override
  final String? dismissed;
  @override
  final String? multiline;
  @override
  final String? image;
  final Map<String, dynamic>? _payload;
  @override
  Map<String, dynamic>? get payload {
    final value = _payload;
    if (value == null) return null;
    if (_payload is EqualUnmodifiableMapView) return _payload;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'NotificationDataPayload(notificationId: $notificationId, id: $id, title: $title, actionCategoryId: $actionCategoryId, body: $body, actions: $actions, url: $url, dismissed: $dismissed, multiline: $multiline, image: $image, payload: $payload)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NotificationDataPayloadImpl &&
            (identical(other.notificationId, notificationId) ||
                other.notificationId == notificationId) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.actionCategoryId, actionCategoryId) ||
                other.actionCategoryId == actionCategoryId) &&
            (identical(other.body, body) || other.body == body) &&
            (identical(other.actions, actions) || other.actions == actions) &&
            (identical(other.url, url) || other.url == url) &&
            (identical(other.dismissed, dismissed) ||
                other.dismissed == dismissed) &&
            (identical(other.multiline, multiline) ||
                other.multiline == multiline) &&
            (identical(other.image, image) || other.image == image) &&
            const DeepCollectionEquality().equals(other._payload, _payload));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      notificationId,
      id,
      title,
      actionCategoryId,
      body,
      actions,
      url,
      dismissed,
      multiline,
      image,
      const DeepCollectionEquality().hash(_payload));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$NotificationDataPayloadImplCopyWith<_$NotificationDataPayloadImpl>
      get copyWith => __$$NotificationDataPayloadImplCopyWithImpl<
          _$NotificationDataPayloadImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$NotificationDataPayloadImplToJson(
      this,
    );
  }
}

abstract class _NotificationDataPayload implements NotificationDataPayload {
  const factory _NotificationDataPayload(
      {final String? notificationId,
      final String? id,
      final String? title,
      final String? actionCategoryId,
      final String? body,
      final String? actions,
      final String? url,
      final String? dismissed,
      final String? multiline,
      final String? image,
      final Map<String, dynamic>? payload}) = _$NotificationDataPayloadImpl;

  factory _NotificationDataPayload.fromJson(Map<String, dynamic> json) =
      _$NotificationDataPayloadImpl.fromJson;

  @override
  String? get notificationId;
  @override
  String? get id;
  @override
  String? get title;
  @override
  String? get actionCategoryId;
  @override
  String? get body;
  @override
  String? get actions;
  @override
  String? get url;
  @override
  String? get dismissed;
  @override
  String? get multiline;
  @override
  String? get image;
  @override
  Map<String, dynamic>? get payload;
  @override
  @JsonKey(ignore: true)
  _$$NotificationDataPayloadImplCopyWith<_$NotificationDataPayloadImpl>
      get copyWith => throw _privateConstructorUsedError;
}

NotificationPayloadAction _$NotificationPayloadActionFromJson(
    Map<String, dynamic> json) {
  return _NotificationPayloadAction.fromJson(json);
}

/// @nodoc
mixin _$NotificationPayloadAction {
  String? get method => throw _privateConstructorUsedError;
  String? get url => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $NotificationPayloadActionCopyWith<NotificationPayloadAction> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NotificationPayloadActionCopyWith<$Res> {
  factory $NotificationPayloadActionCopyWith(NotificationPayloadAction value,
          $Res Function(NotificationPayloadAction) then) =
      _$NotificationPayloadActionCopyWithImpl<$Res, NotificationPayloadAction>;
  @useResult
  $Res call({String? method, String? url});
}

/// @nodoc
class _$NotificationPayloadActionCopyWithImpl<$Res,
        $Val extends NotificationPayloadAction>
    implements $NotificationPayloadActionCopyWith<$Res> {
  _$NotificationPayloadActionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? method = freezed,
    Object? url = freezed,
  }) {
    return _then(_value.copyWith(
      method: freezed == method
          ? _value.method
          : method // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$NotificationPayloadActionImplCopyWith<$Res>
    implements $NotificationPayloadActionCopyWith<$Res> {
  factory _$$NotificationPayloadActionImplCopyWith(
          _$NotificationPayloadActionImpl value,
          $Res Function(_$NotificationPayloadActionImpl) then) =
      __$$NotificationPayloadActionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? method, String? url});
}

/// @nodoc
class __$$NotificationPayloadActionImplCopyWithImpl<$Res>
    extends _$NotificationPayloadActionCopyWithImpl<$Res,
        _$NotificationPayloadActionImpl>
    implements _$$NotificationPayloadActionImplCopyWith<$Res> {
  __$$NotificationPayloadActionImplCopyWithImpl(
      _$NotificationPayloadActionImpl _value,
      $Res Function(_$NotificationPayloadActionImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? method = freezed,
    Object? url = freezed,
  }) {
    return _then(_$NotificationPayloadActionImpl(
      method: freezed == method
          ? _value.method
          : method // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$NotificationPayloadActionImpl implements _NotificationPayloadAction {
  const _$NotificationPayloadActionImpl({this.method, this.url});

  factory _$NotificationPayloadActionImpl.fromJson(Map<String, dynamic> json) =>
      _$$NotificationPayloadActionImplFromJson(json);

  @override
  final String? method;
  @override
  final String? url;

  @override
  String toString() {
    return 'NotificationPayloadAction(method: $method, url: $url)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NotificationPayloadActionImpl &&
            (identical(other.method, method) || other.method == method) &&
            (identical(other.url, url) || other.url == url));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, method, url);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$NotificationPayloadActionImplCopyWith<_$NotificationPayloadActionImpl>
      get copyWith => __$$NotificationPayloadActionImplCopyWithImpl<
          _$NotificationPayloadActionImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$NotificationPayloadActionImplToJson(
      this,
    );
  }
}

abstract class _NotificationPayloadAction implements NotificationPayloadAction {
  const factory _NotificationPayloadAction(
      {final String? method,
      final String? url}) = _$NotificationPayloadActionImpl;

  factory _NotificationPayloadAction.fromJson(Map<String, dynamic> json) =
      _$NotificationPayloadActionImpl.fromJson;

  @override
  String? get method;
  @override
  String? get url;
  @override
  @JsonKey(ignore: true)
  _$$NotificationPayloadActionImplCopyWith<_$NotificationPayloadActionImpl>
      get copyWith => throw _privateConstructorUsedError;
}
